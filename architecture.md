Updated generator contract (v1.1) — now includes files: collections
Purpose

Keep Sveltia config + content as the source of truth and auto-produce a few boring, dependable files so the project can’t drift (paths, formats, types, optional validators). The generator must stay “dumb”: no routes, no joins, no clever site behaviour.

Inputs

A) CMS schema

static/admin/config.yml (or .yaml / .json / .toml)

Read:

collections[]

name

either folder or files

format + extension (especially for files)

fields[] (name, widget, required, multiple, relation config)

B) Content

Paths referenced by:

folder: ... → multiple entries

files: ... file: ... → singletons / data docs

Outputs (still only these three)

All written to src/lib/generated/:

collections.ts

Manifest of collections, supporting both:

kind: 'folder' (multi-entry)

kind: 'files' (named singletons)

Must record:

name, kind, format, extension

for folder: folder

for files: list of file definitions (file, name, label)

types.ts

TS types for entries:

Folder collections → XxxEntry

Files collections → XxxDoc (or XxxEntry, your choice)

Mapping rules:

markdown widget always maps to string

relation uses value_field → string (or string[] if multiple: true)

list:

if it has nested fields → object[]

else → unknown[]

unrecognised → unknown

validate.ts (optional now, but reserved)

Zod validators per type

Format rules (important)

If collection (or file item) declares format, trust it.

If folder collection omits format, default to Markdown + front-matter (format: 'markdown', extension: 'md').

files collections should usually specify format explicitly (as in the illustrasea example).

“Must not do”

Still:

❌ no joins

❌ no route generation

❌ no derived site structure

❌ no aggregation/export catalogue generation (that’s a separate optional script later)

What the generated collections.ts looks like with mixed content

Example: your posts + tags (folder) plus a JSON catalogue document (files).

// src/lib/generated/collections.ts
// AUTO-GENERATED by scripts/generate-schema.mjs
// DO NOT EDIT BY HAND

export const GENERATED_SCHEMA_VERSION = 2 as const;

export type CollectionFormat = 'json' | 'yaml' | 'markdown' | 'unknown';
export type CollectionKind = 'folder' | 'files';

export type FolderCollectionDef = {
	name: string;
	kind: 'folder';
	folder: string;
	format: CollectionFormat;
	extension: string;
};

export type FileItemDef = {
	name: string; // e.g. "landscape_gallery"
	label?: string;
	file: string; // e.g. "_data/landscape-gallery.json"
	format: CollectionFormat;
	extension: string;
};

export type FilesCollectionDef = {
	name: string;
	kind: 'files';
	files: FileItemDef[];
};

export type CollectionDef = FolderCollectionDef | FilesCollectionDef;

export const collections = {
	posts: {
		name: 'posts',
		kind: 'folder',
		folder: 'content/posts',
		format: 'markdown',
		extension: 'md'
	},
	tags: {
		name: 'tags',
		kind: 'folder',
		folder: 'content/tags',
		format: 'markdown',
		extension: 'md'
	},

	// Example "files" JSON doc collection
	site_data: {
		name: 'site_data',
		kind: 'files',
		files: [
			{
				name: 'landscape_gallery',
				label: 'Landscape Illustrations',
				file: '_data/landscape-gallery.json',
				format: 'json',
				extension: 'json'
			}
		]
	}
} as const;

export type CollectionName = keyof typeof collections;

export function getCollection(name: CollectionName): CollectionDef {
	return collections[name];
}

How a mixed project fits neatly in SvelteKit (no tangles)
The key idea

Write one reader that can load:

many entries from folder

one doc from files

…and keep everything else (loaders/endpoints) calling that reader.

src/lib/server/content/read.ts (concept)

readFolderEntries('posts') → list

readFileDoc('site_data', 'landscape_gallery') → one JSON object

Your +page.server.ts can then do:

import { readAll, readDoc } from '$lib/server/content/read';

export async function load() {
	const posts = await readAll('posts');
	const gallery = await readDoc('site_data', 'landscape_gallery');

	return { posts, gallery };
}


That’s the “fits in” story: loaders don’t care whether the source is Markdown or JSON.

Where each format shines

Posts/stories: Markdown front-matter (great authoring, diffs, body editing)

Data catalogues (galleries, menus, indexes): JSON singletons (great structure)
