// scripts/generate-content-api.mjs
// Drop-in replacement — generator is plain JS, but it EMITS TypeScript.
//
// Usage:
//   node scripts/generate-content-api.mjs
//   node scripts/generate-content-api.mjs --config static/admin/config.yml
//
// Outputs:
//   src/lib/content/types.generated.ts
//   src/lib/server/content/api.generated.ts

import fs from 'node:fs/promises';
import path from 'node:path';
import YAML from 'yaml';

const ROOT = process.cwd();

const DEFAULT_CONFIG_PATHS = [
	'static/admin/config.yml',
	'static/admin/config.yaml',
	'config.yml',
	'config.yaml'
];

function titleCase(s) {
	return s ? s.slice(0, 1).toUpperCase() + s.slice(1) : s;
}

// small singulariser good enough for typical Decap/Sveltia collection names
function singular(name) {
	if (name === 'people') return 'person';
	if (name.endsWith('ses')) return name.slice(0, -2);
	if (name.endsWith('s') && name.length > 1) return name.slice(0, -1);
	return name;
}

function pascalFromCollection(name) {
	return titleCase(singular(name));
}

function isFolderCollection(col) {
	return typeof col?.folder === 'string';
}

function isFilesCollection(col) {
	return Array.isArray(col?.files);
}

function readArg(flag) {
	const i = process.argv.indexOf(flag);
	if (i === -1) return null;
	return process.argv[i + 1] ?? null;
}

async function readConfigYaml() {
	const argPath = readArg('--config');
	const candidates = argPath ? [argPath] : DEFAULT_CONFIG_PATHS;

	for (const p of candidates) {
		const full = path.resolve(ROOT, p);
		try {
			const raw = await fs.readFile(full, 'utf8');
			return { configPath: full, config: YAML.parse(raw) };
		} catch {
			// try next
		}
	}

	throw new Error(
		`Could not find config.yml. Tried:\n${candidates.map((p) => `- ${p}`).join('\n')}`
	);
}

// Conservative widget -> TS type mapping
function tsTypeForField(field) {
	const widget = field.widget;

	// relation
	if (widget === 'relation') {
		const isMultiple = field.multiple === true;
		return isMultiple ? 'string[]' : 'string';
	}

	// string-ish
	if (
		widget === 'string' ||
		widget === 'text' ||
		widget === 'markdown' ||
		widget === 'image' ||
		widget === 'file' ||
		widget === 'datetime' ||
		widget === 'date' ||
		widget === 'select'
	) {
		return 'string';
	}

	if (widget === 'boolean') return 'boolean';
	if (widget === 'number') return 'number';

	return 'unknown';
}

// Decap/Sveltia: required defaults to true if omitted
function isOptionalField(field) {
	return field.required === false;
}

function pluralise(name) {
	// tiny helper – good enough for your use-case
	if (name.endsWith('y') && !/[aeiou]y$/i.test(name)) return name.slice(0, -1) + 'ies';
	if (name.endsWith('s')) return name; // already plural-ish (posts, tags, etc.)
	return name + 's';
}

// Avoid duplicate keys: slug/body/excerpt are always provided by our domain model for folder collections.
function isReservedFieldName(name) {
	return name === 'slug' || name === 'body' || name === 'excerpt';
}

function emitHeader(comment) {
	return `/*\n * AUTO-GENERATED FILE — DO NOT EDIT.\n * Generated by scripts/generate-content-api.mjs\n * ${comment}\n */\n`;
}

function coercerForTsType(tsType) {
	if (tsType === 'string') return 'asString';
	if (tsType === 'boolean') return 'asBoolean';
	if (tsType === 'number') return 'asNumber';
	if (tsType === 'string[]') return 'asStringArray';
	return 'pick';
}

function emitCoercersTs() {
	// This is TypeScript code, emitted into api.generated.ts as a string.
	return `
function asString(x: unknown): string {
	return typeof x === 'string' ? x : '';
}
function asBoolean(x: unknown): boolean {
	return x === true;
}
function asNumber(x: unknown): number {
	return typeof x === 'number' && Number.isFinite(x) ? x : 0;
}
function asStringArray(x: unknown): string[] {
	if (Array.isArray(x)) return x.filter((v): v is string => typeof v === 'string');
	if (typeof x === 'string' && x.length) return [x];
	return [];
}
function pick<T>(x: T): T {
	return x;
}
`.trim();
}

function safeDocTypeName(colName, docName) {
	// eg settings + site => SettingsSite
	return `${titleCase(colName)}${titleCase(docName)}`;
}

function generateTypesFile(config) {
	const cols = config.collections ?? [];
	const folderCols = cols.filter(isFolderCollection);
	const filesCols = cols.filter(isFilesCollection);

	let out = '';
	out += emitHeader('Types derived from config.yml');
	out += `\n// Widget -> TS mapping is conservative (select = string, etc.)\n\n`;
	out += `export type Slug = string;\n\n`;

	for (const col of folderCols) {
		const name = col.name;
		const TypeName = pascalFromCollection(name);
		const fields = Array.isArray(col.fields) ? col.fields : [];

		out += `export type ${TypeName} = {\n`;
		out += `\tslug: Slug;\n`;

		for (const f of fields) {
			if (!f?.name) continue;
			if (isReservedFieldName(f.name)) continue;

			const tsType = tsTypeForField(f);
			const optional = isOptionalField(f);
			out += `\t${f.name}${optional ? '?:' : ':'} ${tsType};\n`;
		}

		// Always include markdown body + excerpt for folder collections
		out += `\tbody: string;\n`;
		out += `\texcerpt: string;\n`;
		out += `};\n\n`;
	}

	// Files collections: create a type per doc
	for (const col of filesCols) {
		const colName = col.name;
		for (const fileDef of col.files) {
			const docName = fileDef.name;
			const TypeName = safeDocTypeName(colName, docName);
			const fields = Array.isArray(fileDef.fields) ? fileDef.fields : [];

			out += `export type ${TypeName} = {\n`;
			out += `\tname: string; // "${docName}"\n`;

			for (const f of fields) {
				if (!f?.name) continue;
				if (f.name === 'body') continue; // doc body is separate
				const tsType = tsTypeForField(f);
				const optional = isOptionalField(f);
				out += `\t${f.name}${optional ? '?:' : ':'} ${tsType};\n`;
			}

			out += `\tbody: string;\n`;
			out += `};\n\n`;
		}
	}

	return out;
}

function generateApiFile(config) {
	const cols = config.collections ?? [];
	const folderCols = cols.filter(isFolderCollection);
	const filesCols = cols.filter(isFilesCollection);

	const typeNames = [];
	for (const col of folderCols) typeNames.push(pascalFromCollection(col.name));
	for (const col of filesCols) {
		for (const fileDef of col.files) {
			typeNames.push(safeDocTypeName(col.name, fileDef.name));
		}
	}

	let out = '';
	out += emitHeader('Content API derived from config.yml');

	// IMPORTANT: api.generated.ts is TypeScript, so we can use TS types here.
	out += `
import { readAll, readOne, readDoc } from '$lib/server/content/read';
import type { ReadResult } from '$lib/server/content/read';
import type {
${typeNames.map((t) => `\t${t},`).join('\n')}
} from '$lib/content/types.generated';
`.trim();
	out += `\n\n`;
	out += emitCoercersTs();
	out += `\n\n`;

	// Folder collection APIs
	for (const col of folderCols) {
		const name = col.name; // e.g. posts
		const TypeName = pascalFromCollection(name); // Post

		let pluralFn = `get${titleCase(name)}`; // e.g. getPosts, getPeople, getTypography
		const singleFn = `get${TypeName}`; // e.g. getPost, getPerson, getTypography

		// Avoid collisions like typography -> getTypography (plural) + getTypography (single)
		if (pluralFn === singleFn) {
			pluralFn = `get${TypeName}All`; // e.g. getTypographyAll
		}

		const fields = Array.isArray(col.fields) ? col.fields : [];

		// detect "draft" or "status" field conventions
		const hasDraft = fields.some((f) => f?.name === 'draft' && tsTypeForField(f) === 'boolean');
		const hasStatus = fields.some((f) => f?.name === 'status' && tsTypeForField(f) === 'string');

		// relation fields to generate join helpers
		const relationFields = fields.filter(
			(f) => f?.widget === 'relation' && typeof f.collection === 'string'
		);

		// Mapper
		out += `function map${TypeName}(row: ReadResult): ${TypeName} {\n`;
		out += `\tconst data = (row.data ?? {}) as Record<string, unknown>;\n`;
		out += `\tconst body = typeof row.body === 'string' ? row.body : '';\n`;
		out += `\treturn {\n`;
		out += `\t\tslug: row.meta?.slug ?? '',\n`;

		for (const f of fields) {
			if (!f?.name) continue;
			if (isReservedFieldName(f.name)) continue;

			const tsType = tsTypeForField(f);
			const coerce = coercerForTsType(tsType);
			out += `\t\t${f.name}: ${coerce}(data['${f.name}']),\n`;
		}

		out += `\t\tbody,\n`;
		out += `\t\texcerpt: body ? body.slice(0, 200) : ''\n`;
		out += `\t};\n`;
		out += `}\n\n`;

		// getAll (only include opts/includeDrafts when relevant)
		if (hasDraft || hasStatus) {
			out += `export async function ${pluralFn}(opts: { includeDrafts?: boolean } = {}): Promise<${TypeName}[]> {\n`;
			out += `\tconst { includeDrafts = false } = opts;\n`;
			out += `\tconst rows = await readAll('${name}');\n`;
			out += `\tlet items = rows.map(map${TypeName});\n`;

			if (hasDraft) {
				out += `\tif (!includeDrafts) items = items.filter((p) => (p as any).draft !== true);\n`;
			} else if (hasStatus) {
				out += `\tif (!includeDrafts) items = items.filter((p) => ((p as any).status ?? 'published') !== 'draft');\n`;
			}

			out += `\treturn items;\n`;
			out += `}\n\n`;
		} else {
			out += `export async function ${pluralFn}(): Promise<${TypeName}[]> {\n`;
			out += `\tconst rows = await readAll('${name}');\n`;
			out += `\treturn rows.map(map${TypeName});\n`;
			out += `}\n\n`;
		}

		// getOne (only include opts when relevant)
		if (hasDraft || hasStatus) {
			out += `export async function ${singleFn}(slug: string, opts: { includeDrafts?: boolean } = {}): Promise<${TypeName} | null> {\n`;
			out += `\tconst row = await readOne('${name}', slug);\n`;
			out += `\tif (!row) return null;\n`;
			out += `\tconst item = map${TypeName}(row);\n`;

			out += `\tif (opts.includeDrafts !== true) {\n`;
			if (hasDraft) out += `\t\tif ((item as any).draft === true) return null;\n`;
			if (hasStatus)
				out += `\t\tif (((item as any).status ?? 'published') === 'draft') return null;\n`;
			out += `\t}\n`;

			out += `\treturn item;\n`;
			out += `}\n\n`;
		} else {
			out += `export async function ${singleFn}(slug: string): Promise<${TypeName} | null> {\n`;
			out += `\tconst row = await readOne('${name}', slug);\n`;
			out += `\treturn row ? map${TypeName}(row) : null;\n`;
			out += `}\n\n`;
		}

		// Join helpers for relation fields
		for (const rf of relationFields) {
			const targetCollection = rf.collection; // e.g. tags
			const targetType = pascalFromCollection(targetCollection); // Tag
			const joinName = `join${titleCase(name)}With${titleCase(targetCollection)}`;
			const propName = rf.name; // e.g. tags
			const joinedProp = `${propName}Objects`; // e.g. tagsObjects
			const isMultiple = rf.multiple === true;

			out += `export function ${joinName}(${name}: ${TypeName}[], ${targetCollection}: ${targetType}[]): ${TypeName}[] {\n`;
			out += `\tconst index = new Map(${targetCollection}.map((t) => [t.slug, t] as const));\n`;
			out += `\treturn ${name}.map((p) => {\n`;

			if (isMultiple) {
				out += `\t\tconst resolved = Array.isArray((p as any)['${propName}'])\n`;
				out += `\t\t\t? ((p as any)['${propName}'] as unknown[])\n`;
				out += `\t\t\t\t.filter((s): s is string => typeof s === 'string')\n`;
				out += `\t\t\t\t.map((s) => index.get(s))\n`;
				out += `\t\t\t\t.filter(Boolean)\n`;
				out += `\t\t\t: [];\n`;
				out += `\t\treturn { ...(p as any), ${joinedProp}: resolved } as ${TypeName};\n`;
			} else {
				out += `\t\tconst key = (p as any)['${propName}'];\n`;
				out += `\t\tconst resolved = typeof key === 'string' && key ? index.get(key) : undefined;\n`;
				out += `\t\treturn { ...(p as any), ${joinedProp}: resolved } as ${TypeName};\n`;
			}

			out += `\t});\n`;
			out += `}\n\n`;
		}
	}

	// Files collection APIs (docs)
	for (const col of filesCols) {
		const colName = col.name;
		for (const fileDef of col.files) {
			const docName = fileDef.name;
			const TypeName = safeDocTypeName(colName, docName);
			const fnName = `get${TypeName}`;
			const fields = Array.isArray(fileDef.fields) ? fileDef.fields : [];

			out += `function map${TypeName}(row: ReadResult): ${TypeName} {\n`;
			out += `\tconst data = (row.data ?? {}) as Record<string, unknown>;\n`;
			out += `\tconst body = typeof row.body === 'string' ? row.body : '';\n`;
			out += `\treturn {\n`;
			out += `\t\tname: '${docName}',\n`;

			for (const f of fields) {
				if (!f?.name) continue;
				if (f.name === 'body') continue;

				const tsType = tsTypeForField(f);
				const coerce = coercerForTsType(tsType);
				out += `\t\t${f.name}: ${coerce}(data['${f.name}']),\n`;
			}

			out += `\t\tbody\n`;
			out += `\t};\n`;
			out += `}\n\n`;

			out += `export async function ${fnName}(): Promise<${TypeName}> {\n`;
			out += `\tconst row = await readDoc('${colName}', '${docName}');\n`;
			out += `\treturn map${TypeName}(row);\n`;
			out += `}\n\n`;
		}
	}

	return out;
}

async function main() {
	const outDirTypes = path.resolve(ROOT, 'src/lib/content');
	const outDirApi = path.resolve(ROOT, 'src/lib/server/content');

	const { configPath, config } = await readConfigYaml();

	const typesTs = generateTypesFile(config);
	const apiTs = generateApiFile(config);

	await fs.mkdir(outDirTypes, { recursive: true });
	await fs.mkdir(outDirApi, { recursive: true });

	const typesPath = path.join(outDirTypes, 'types.generated.ts');
	const apiPath = path.join(outDirApi, 'api.generated.ts');

	await fs.writeFile(typesPath, typesTs, 'utf8');
	await fs.writeFile(apiPath, apiTs, 'utf8');

	console.log(`✅ Generated:\n- ${typesPath}\n- ${apiPath}\n(using ${configPath})`);
}

main().catch((err) => {
	console.error('❌ generate-content-api failed:', err);
	process.exit(1);
});
